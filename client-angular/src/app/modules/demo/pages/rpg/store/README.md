# RPG Demo

[NgRx Tips I Needed in the Beginning](https://dev.to/this-is-angular/ngrx-tips-i-needed-in-the-beginning-4hno)

## Managing State with NgRx

Prior to Angular 16+, most apps registered NgRx state using `StoreModule.forRoot` and `StoreModule.forFeature`.&nbsp; But with Angular 16+ and NgRx 16+, the new provider-based APIs (`provideStore`, `provideState`, etc.) became the modern best practice.&nbsp; The provider-based API is now preferred for simplicity, type-safety, and tree-shakability.

> **Q:**&nbsp; Do I need a State interface for every feature with `createFeature` and `provideState`?

- Yes, and that’s good! Each feature should declare its own strongly-typed State (and often uses NgRx’s `EntityState<T>`)
- No longer need to manually compose a big `RootState` interface — NgRx assembles your root state automatically based on your `provideState` calls
- Each feature’s initial state and reducer logic is encapsulated in that feature’s file, making things modular and easier to extend/test

> **Q:**&nbsp; What should I inject into effects: `Store`, `Store<State>`, or `Store<RootState>`?

- **Best practice:**&nbsp; Inject `private store: Store` (the generic store) in your effects and components
- Use the selectors generated by your feature (e.g. `attributeFeature.selectAll`) — these are fully typed and point to your feature slice
- You almost never need to inject a store with a feature-specific or root state type

### NgRx in RPG Demo

Should `.select` and dispatch actions live in components or services?

- **Selectors (`.select`):**&nbsp; Use in components (with the async pipe).&nbsp; You can also use them in services if you want to create "facade" services to abstract store logic from your UI (optional, but nice in bigger apps).
- **Dispatch actions:**&nbsp; Can be in components or in facade services.&nbsp; If you use facades, components stay clean and only interact with observables and facade methods.

```typescript
import { Component, inject } from '@angular/core';
import { Store } from '@ngrx/store';
import { attributeFeature } from '../state/attribute/attribute.reducer';
import { AttributeActions } from '../state/attribute/attribute.actions';

@Component({
  selector: 'rpg-attribute-list',
  template: `
    <button (click)="load()">Load</button>
    @for (attr of attributes$ | async; track attr.id) {
      <div>{{ attr.name }}: {{ attr.value }}</div>
    }
  `,
})
export class AttributeListComponent {
  private store = inject(Store);
  attributes$ = this.store.select(attributeFeature.selectAll);

  load() {
    this.store.dispatch(AttributeActions.load());
  }
}
```

---

### Key Points

- **GameState:**&nbsp; a first-class NgRx feature, just like Attributes, Characters, etc. (prefer flattened data over nested wherever able)
- **Effects:**&nbsp; handle loading/saving from `localStorage`
- **Facades:**&nbsp; ties together all features, NgRx or otherwise - expose observables/selectors for components
- **Components:**&nbsp; use the facade’s observables for all state-driven UI

#### Summary Table

| Layer        | Old Approach              | NgRx v18 Approach              |
| ------------ | ------------------------- | ------------------------------ |
| GameState    | Service/BehaviorSubject   | NgRx feature slice + selectors |
| Load/Save    | Service methods           | NgRx effects (`localStorage`)  |
| Access in UI | Facade/service properties | Facade with store selectors    |
| Update in UI | Facade/service methods    | Facade dispatches actions      |
